import { generateId } from '../generate';
import type { HttpStatusError } from '../http-status';

type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';

type ExceptionOptions = {
	name?: string;
	cause?: unknown;
	/* The HTTP status code generated by the origin server for this occurrence of the problem. */
	status?: HttpStatusError;
	/* Unique identifier for the error. */
	traceId?: string;
	/* Metadata and custom properties. */
	meta?: { [key: string]: unknown };
	/* A human-readable message for the error, can be displayed frontend. */
	readableMessage?: string;
	logLevel?: LogLevel;
};

export class Exception extends Error {
	__exception = true;
	/* Unique identifier for the error. */
	traceId: string;
	/* The HTTP status code generated by the origin server for this occurrence of the problem. */
	status: HttpStatusError;
	/* The time the error occurred (ms since epoch). */
	timestamp = Date.now();
	/* Metadata and custom properties. */
	meta: { [key: string]: unknown };
	/* A human-readable message for the error, can be displayed frontend. */
	readableMessage?: string;
	/* The log level for the error. */
	logLevel: LogLevel;

	/**
	 * Constructor for the custom exception.
	 *
	 * @param message - The error message.
	 * @param options - Optional object containing additional error details.
	 */
	constructor(message: string, options?: ExceptionOptions) {
		super(message);
		this.status = options?.status ?? 500;
		this.cause = options?.cause;
		this.name = options?.name || new.target.name;
		this.traceId = options?.traceId || generateId(8);
		this.readableMessage = options?.readableMessage;
		this.meta = Object.assign(
			{},
			options?.meta,
			(options?.cause as Exception | undefined)?.meta,
		);
		this.logLevel = options?.logLevel ?? 'error';

		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, new.target);
		}

		Object.setPrototypeOf(this, new.target.prototype);
	}

	toJson() {
		return {
			message: this.message,
			name: this.name,
			status: this.status,
			timestamp: this.timestamp,
			traceId: this.traceId,
			meta: this.meta,
			readableMessage: this.readableMessage,
		};
	}
}

export interface ExceptionConstructor {
	readonly prototype: Exception;
	new (message?: string, options?: ExceptionOptions): Exception;
}

/**
 * Creates a custom exception class.
 *
 * @param properties - Default properties including message and HTTP status.
 * @returns The Exception class with provided default properties.
 */
export const createCustomException = (properties: {
	defaultMessage: string;
	defaultName?: string;
	defaultStatus?: HttpStatusError;
	defaultLogLevel?: LogLevel;
}): ExceptionConstructor => {
	return class extends Exception {
		/**
		 * Constructor for the custom exception.
		 *
		 * @param message - The error message.
		 * @param options - Optional object containing additional error details.
		 */
		constructor(
			message: string = properties.defaultMessage,
			options?: ExceptionOptions,
		) {
			super(message, {
				...options,
				name: options?.name || properties.defaultName,
				status: options?.status ?? properties.defaultStatus,
				logLevel: options?.logLevel ?? properties.defaultLogLevel,
			});
		}
	};
};
