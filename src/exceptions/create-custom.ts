import { generateId } from '../generate';
import { SafeJson } from '../safe-json';
import type { HttpStatusError } from '../http-status';

type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';

export type ExceptionOptions = {
  /* The error name. */
  name?: string;

  /* The error cause. */
  cause?: unknown;

  /* The HTTP status code generated by the origin server for this occurrence of the problem. */
  status?: HttpStatusError;

  /* Unique identifier for the error. */
  traceId?: string;

  /* Metadata and custom properties. */
  meta?: { [key: string]: unknown };

  /* A human-readable message for the error, can be displayed frontend. */
  readableMessage?: string;

  /* The time the error occurred (ms since epoch). */
  timestamp?: number;

  /* The log level for the error. */
  logLevel?: LogLevel;

  /* Stack trace. */
  stack?: string;
};

export type FormattedException = ReturnType<typeof Exception.prototype.toJson>;

type Mutable<TargetType> = {
  -readonly [Key in keyof TargetType]: TargetType[Key];
};

export class Exception extends Error {
  readonly __exception = true;
  /* Unique identifier for the error. */
  readonly traceId: string;
  /* The HTTP status code generated by the origin server for this occurrence of the problem. */
  readonly status: HttpStatusError;
  /* The time the error occurred (ms since epoch). */
  readonly timestamp: number;
  /* A human-readable message for the error, can be displayed frontend. */
  readonly readableMessage?: string;
  /* Metadata and custom properties. */
  readonly meta: { [key: string]: unknown };
  /* The log level for the error. */
  logLevel: LogLevel;

  /**
   * Constructor for the custom exception.
   * @param message - The error message.
   * @param options - Optional object containing additional error details.
   */
  constructor(message: string, options?: ExceptionOptions) {
    super(message);
    this.status = options?.status ?? 500;
    this.cause = options?.cause ?? undefined;
    this.name = options?.name || new.target.name;
    this.traceId = options?.traceId || generateId(8);
    this.readableMessage = options?.readableMessage ?? undefined;
    this.timestamp = options?.timestamp ?? Date.now();
    this.meta = Object.assign(
      {},
      options?.meta,
      (options?.cause as Exception | undefined)?.meta,
    );
    this.logLevel = options?.logLevel ?? 'error';

    if (options?.stack) {
      this.stack = options.stack;
    } else if ((options?.cause as Error)?.stack) {
      this.stack = (options?.cause as Error)?.stack;
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }

    Object.setPrototypeOf(this, new.target.prototype);
  }

  toJson() {
    return {
      __exception: this.__exception,
      message: this.message,
      name: this.name,
      status: this.status,
      timestamp: this.timestamp,
      traceId: this.traceId,
      meta: SafeJson.isStringifyable(this.meta) ? this.meta : undefined,
      cause: SafeJson.isStringifyable(this.cause) ? this.cause : undefined,
      readableMessage: this.readableMessage,
      stack: this.stack,
      logLevel: this.logLevel,
    };
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }

  get [Symbol.toStringTag](): string {
    return 'Exception';
  }

  addMeta(meta: { [key: string]: unknown }): this {
    (this as Mutable<Exception>).meta = Object.assign({}, this.meta, meta);

    return this;
  }

  static from(
    error: string | Exception | Error | FormattedException,
    options?: ExceptionOptions,
  ): Exception {
    if (error instanceof Exception) {
      return error;
    }

    if (error instanceof Error) {
      return new Exception(error.message, {
        cause: error,
        ...error,
        ...options,
      });
    }

    if (typeof error === 'string') {
      if (error.includes('"__exception":true') && SafeJson.isParsable(error)) {
        const json = JSON.parse(error) as FormattedException;

        return new Exception(json.message, { ...json, ...options });
      }

      return new Exception(error, options);
    }

    if (error.__exception) {
      return new Exception(error.message, error);
    }

    return new Exception(error.message ?? 'Unknown error type', {
      ...error,
      ...options,
    });
  }
}

export type ExceptionConstructor = {
  readonly prototype: Exception;
  new (message?: string, options?: ExceptionOptions): Exception;
};

/**
 * Creates a custom exception class.
 * @param properties - Default properties including message and HTTP status.
 * @param properties.defaultMessage
 * @param properties.defaultName
 * @param properties.defaultStatus
 * @param properties.defaultLogLevel
 * @returns The Exception class with provided default properties.
 */
export const createCustomException = (properties: {
  defaultMessage: string;
  defaultName?: string;
  defaultStatus?: HttpStatusError;
  defaultLogLevel?: LogLevel;
}): ExceptionConstructor => {
  return class extends Exception {
    /**
     * Constructor for the custom exception.
     * @param message - The error message.
     * @param options - Optional object containing additional error details.
     */
    constructor(
      message: string = properties.defaultMessage,
      options?: ExceptionOptions,
    ) {
      super(message, {
        ...options,
        name: options?.name || properties.defaultName,
        status: options?.status ?? properties.defaultStatus,
        logLevel: options?.logLevel ?? properties.defaultLogLevel,
      });
    }
  };
};
