import { generateId } from '../generate';
import type { HttpStatusError } from '../http-status';
import { SafeJson } from '../safe-json';

type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';

type ExceptionOptions = {
	/* The error name. */
	name?: string;

	/* The error cause. */
	cause?: unknown;

	/* The HTTP status code generated by the origin server for this occurrence of the problem. */
	status?: HttpStatusError;

	/* Unique identifier for the error. */
	traceId?: string;

	/* Metadata and custom properties. */
	meta?: { [key: string]: unknown };

	/* A human-readable message for the error, can be displayed frontend. */
	readableMessage?: string;

	/* The time the error occurred (ms since epoch). */
	timestamp?: number;

	/* The log level for the error. */
	logLevel?: LogLevel;

	/* Stack trace. */
	stack?: string;
};

type FormattedException = ReturnType<typeof Exception.prototype.toJson>;

export class Exception extends Error {
	__exception = true;
	/* Unique identifier for the error. */
	traceId: string;
	/* The HTTP status code generated by the origin server for this occurrence of the problem. */
	status: HttpStatusError;
	/* The time the error occurred (ms since epoch). */
	timestamp: number;
	/* Metadata and custom properties. */
	meta: { [key: string]: unknown };
	/* A human-readable message for the error, can be displayed frontend. */
	readableMessage?: string;
	/* The log level for the error. */
	logLevel: LogLevel;

	/**
	 * Constructor for the custom exception.
	 *
	 * @param message - The error message.
	 * @param options - Optional object containing additional error details.
	 */
	constructor(message: string, options?: ExceptionOptions) {
		super(message);
		this.status = options?.status ?? 500;
		this.cause = options?.cause ?? undefined;
		this.name = options?.name || new.target.name;
		this.traceId = options?.traceId || generateId(8);
		this.readableMessage = options?.readableMessage ?? undefined;
		this.timestamp = options?.timestamp ?? Date.now();
		this.meta = Object.assign(
			{},
			options?.meta,
			(options?.cause as Exception | undefined)?.meta,
		);
		this.logLevel = options?.logLevel ?? 'error';

		if (options?.stack) {
			this.stack = options.stack;
		} else if ((options?.cause as Error)?.stack) {
			this.stack = (options?.cause as Error)?.stack;
		} else if (Error.captureStackTrace) {
			Error.captureStackTrace(this, this.constructor);
		} else {
			this.stack = new Error().stack;
		}

		Object.setPrototypeOf(this, new.target.prototype);
	}

	toJson() {
		return {
			__exception: this.__exception,
			message: this.message,
			name: this.name,
			status: this.status,
			timestamp: this.timestamp,
			traceId: this.traceId,
			meta: this.meta,
			cause: this.cause,
			readableMessage: this.readableMessage,
			stack: this.stack,
		};
	}

	toString(): string {
		return JSON.stringify(this.toJson());
	}

	get [Symbol.toStringTag](): string {
		return 'Exception';
	}

	static from(
		error: string | Exception | Error | FormattedException,
		options?: ExceptionOptions,
	): Exception {
		if (error instanceof Exception) {
			return error;
		}

		if (error instanceof Error) {
			return new Exception(error.message, {
				cause: error,
				...error,
				...options,
			});
		}

		if (typeof error === 'string') {
			if (error.includes('"__exception":true') && SafeJson.isParsable(error)) {
				const json = JSON.parse(error) as FormattedException;
				return new Exception(json.message, { ...json, ...options });
			}

			return new Exception(error, options);
		}

		if (error.__exception) {
			return new Exception(error.message, error);
		}

		throw new Exception('Unknown error type', {
			...options,
			cause: error,
			meta: { error: error },
		});
	}
}

export interface ExceptionConstructor {
	readonly prototype: Exception;
	new (message?: string, options?: ExceptionOptions): Exception;
}

/**
 * Creates a custom exception class.
 *
 * @param properties - Default properties including message and HTTP status.
 * @returns The Exception class with provided default properties.
 */
export const createCustomException = (properties: {
	defaultMessage: string;
	defaultName?: string;
	defaultStatus?: HttpStatusError;
	defaultLogLevel?: LogLevel;
}): ExceptionConstructor => {
	return class extends Exception {
		/**
		 * Constructor for the custom exception.
		 *
		 * @param message - The error message.
		 * @param options - Optional object containing additional error details.
		 */
		constructor(
			message: string = properties.defaultMessage,
			options?: ExceptionOptions,
		) {
			super(message, {
				...options,
				name: options?.name || properties.defaultName,
				status: options?.status ?? properties.defaultStatus,
				logLevel: options?.logLevel ?? properties.defaultLogLevel,
			});
		}
	};
};
